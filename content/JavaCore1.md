# Java Core-1

## ООП

#### 1. Что такое ООП?
ООП - методология программирования, центральное место в которой занимает объект. Программа же в целом - совокупность объектов (экземпляров классов).
 Класс в свою очередь представляет собой шаблон и состоит из:
  - Полей
  - Конструктора 
  - Методов

#### 2. Какие преимущества у ООП?
- Делим программу на «модули»-классы, ОБЪЕКТЫ каждый из которых делает свою часть работы.
- Код можно повторно использовать в любом месте программы, это экономит время (не нужно писать однотипные функции для разных сущностей).
- «Более естественная» декомпозиция ПО существенно облегчает его разработку (код легко читается и быстро пишется).
- Возможность создавать расширяемые системы (extensible systems), именно это отличает ООП от традиционных методов программирования.
  
#### 3. Какие недостатки у ООП?
 Снижение производительности, увеличение потребности памяти (Информация распределяется на множество мелких инкапсулированных объектов ⇒ на них растет количество ссылок)

#### 4. Принципы ООП (наследование, инкапсуляция, полиморфизм, абстракция)
 **Инкапсуляция** - объединение данных и методов, работающих с ними в одном классе, а так же сокрытие деталей реализации от пользователя. Очевидные примеры инкапсуляции - это: модификаторы доступа, getter-ы и setter-ы.

 **Наследование** - возможность порождать один класс от другого(родительского) с сохранением всех его свойств и методов, добавляя при необходимости новые свойства и методы

 **Полиморфизм** - возможность использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. Полиморфизм бывает:
  - Динамическим (`@Override`)
 Берем метод из родительского класса и пишем свою - специфическую реализацию
  - Статическим (перегрузка)
 Можно определить внутри одного класса несколько методов с одинаковым названием, но при условии, что параметры этих методов различны

 **Абстракция** – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, абстракция – это набор всех таких характеристик.

#### 5. Класс, объект, интерфейс
 **Класс** – это описание ещё не созданного объекта, общий шаблон.
Шаблон состоит из:
   - полей (имя, возраст для чел. и т.д.). Состояние/ряд меняющихся свойств.
   - конструктора (первоначально инициализирует объект, заполняет нужные поля)
   - методов (что умеет делать объект). Действия, функции конкретного объекта.
  
 **Объект** – это экземпляр класса, созданный по шаблону (выше) с собственным состоянием свойств.

 **Интерфейс** — это абстрактный тип, который определяет контракт (набор методов), который должен реализовывать любой класс, подписавшийся на этот интерфейс. Интерфейсы позволяют задавать общие действия, которые могут выполнять различные классы, не завися от их конкретной реализации.

#### 6. Ассоциация, агрегация, композиция
 **Ассоциация** означает, что объекты двух классов могут ссылаться один на другой, иметь связь друг с другом. Один класс включает в себя другой класс в качестве одного из полей.

>**Агрегация** и **композиция** являются частными случаями ассоциации. Это более конкретизированные отношения между объектами.

 **Композиция** — это более жёсткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежать кому-то.
    (Страница принадлежит только одной Книге.)

 **Агрегация** — отношение, когда один объект является частью другого. 
    (Двигатель поставили в одну машину, потом в другую.)

#### 7. Статическое и динамическое связывание
 **Связывание** - процесс, в ходе которого программа решает, какой метод или переменная должна быть вызвана или использована. Связывание бывает:
  - Раннее статическое.  Если метод известен компилятору, то происходит на этапе компиляции. Применяется для дженериков, перегруженных, `private`, `final` и `static` методов. Используются не объекты, а информация о типе, то есть ссылка
  -  Позднее динамическое. Происходит во время выполнения программы JVM. Используется для абстрактных и переопределенных методов
  

#### 8. Является – «is a», имеет – «has a»
  **Наследование** «is a» ЯВЛЯТЬСЯ (обобщение/расширение) – очень мощная связь

  **Ассоциация** «has a» ИМЕТЬ (объекты ИМЕЮТ ссылки/ссылаются друг на друга)

## SOLID

#### 1. Что такое SOLID(каждая буква)?
  **SOLID** – это принципы разработки программного обеспечения, следуя которым получаем хороший код, который в дальнейшем будет хорошо масштабироваться и поддерживаться в рабочем состоянии.

  **S** Single Responsibility Principle – принцип единственной ответственности.Каждый класс должен иметь только одну зону ответственности.
 
  **O** Open closed Principle – принцип открытости-закрытости.Классы должны быть открыты для расширения, но закрыты для изменения.
  
  **L** Liskov substitution Principle – принцип подстановки Барбары Лисков. Должна быть возможность вместо базового (родительского) типа класса подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться.
  
  **I** Interface Segregation Principle – это принцип разделения интерфейсов. Данный принцип обозначает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.
  
  **D** Dependency Inversion Principle – это принцип инверсии зависимостей. Абстракции НЕ должны зависеть от деталей. Детали должны зависеть от абстракций. Модули верхнего уровня НЕ должны зависеть от модулей нижнего уровня, НО должны зависеть от абстракции.

#### 2. Какие еще принципы можешь назвать?
1. **DRY** / Don't Repeat Yourself — Не повторяйся!
2. **KISS** / Keep It Simple Stupid — Делай это проще
3. **OR** / Occam's Razor — Бритва Оккама


## JAVA

#### 1. Расскажи мне про контракт Equals&Hashcode
- Если два объекта возвращают разные значения `hashCode()`, то они не могут быть равны
- Если `equals()` объектов true, то и хеш-коды должны быть равны
- Переопределив `equals()`, всегда переопределять `hashCode()`
- Если у объектов одинаковый `hashCode()`, то они не обязательно `equals()` 
- При каждом вызове `hashCode()` для одного и того же объекта должен возвращаться один и тот же хеш-код

#### 2. Расскажи мне про свойства Equals&Hashcode
 **equals()**. Метод `equals` реализует отношение эквивалентности, которое обладает следующими свойствами:
  - **Рефлексивность**. Объект должен быть равен самому себе (`x.equals(x) == true`)
  - **Симметричность**. Любые два объекта должны иметь одно и то же мнение относительно своего равенства или неравенства (`x.equals(y) == true` и `y.equals(x) == true`)
  - **Транзитивность**. Если один объект равен второму, а второй равен третьему, то и первый объект должен быть равен третьему (`x.equals(y) == true` и `y.equals(z) == true` и `x.equals(z) == true`)
  - **Непротиворечивость**. Если два объекта эквивалентны, они должны быть эквивалентны всегда, пока один из них (или оба они) не будет изменен

  **hashCode():**
  - **Согласованность**. При каждом вызове `hashCode()` для одного и того же объекта в рамках одной программы должно возвращаться одно и то же значение, если поля объекта, участвующие в расчете хэш-кода, не изменились.
  - **Равенство и хэш-код.** Если два объекта равны по методу `equals()`, их хэш-коды тоже должны быть равны. Однако обратное не обязательно — объекты с одинаковым хэш-кодом могут быть не равны
  - **Распределение**. Хороший хэш-код должен распределять объекты по разным корзинам хэш-таблицы для эффективной работы хэш-структур данных, таких как HashMap или HashSet

#### 3. Что такое коллизия?
 Коллизия возникает, когда у разных объектов одинаковые хеш-коды

#### 4. Зачем переопределять методы equals в HashMap? 
  Методы `equals()` и `hashCode()` необходимо переопределять в классах, которые используются в качестве ключей в HashMap, чтобы обеспечить корректное поведение этой структуры данных:
  - `equals()`: Определяет, когда два объекта считаются равными. Если два объекта равны, их хэш-коды также должны быть равными.
  - `hashCode()`: Генерирует числовое значение, которое используется для определения корзины (bucket) в HashMap. Правильное переопределение важно, чтобы объекты, которые равны по `equals()`, имели одинаковый `hashCode()`. Иначе, одинаковые объекты могут попасть в разные корзины, что нарушит работу HashMap.

#### 5. Что будет, если переопределить `equals()` не переопределяя `hashCode()`? Какие могут возникнуть проблемы?
- Объект, который по `equals()` равен существующему ключу в HashMap, может не быть найден, если их хэш-коды различаются. Это связано с тем, что HashMap сначала использует `hashCode()` для поиска корзины, а уже потом сравнивает объекты по `equals()`.
- При попытке удалить ключ, который равен другому ключу по `equals()`, но имеет другой `hashCode()`, удаление может не сработать.

#### 6. Какие типы ссылок существуют в Java?
- **Сильная ссылка.** Обычная ссылка, которая повсеместно используется (`Object obj = new Object()`). Объект не будет удален сборщиком мусора, пока на него есть хотя бы одна сильная ссылка
- **Мягкая ссылка.** Используются для кеширования. Объект, на который ссылается мягкая ссылка, будет удален сборщиком мусора только при нехватке памяти (`SoftReference<MyObject> softRef = new SoftReference<>(new MyObject())`)
- **Слабая ссылка.** Объект, на который ссылается слабая ссылка, может быть удален сборщиком мусора при следующей проверке, даже если на него есть слабые ссылки (`WeakReference<MyObject> weakRef = new WeakReference<>(new MyObject())`)
- **Фантомная ссылка**. Используется для отслеживания, когда объект был удален из памяти. Фантомная ссылка не позволяет получить доступ к объекту напрямую, она только сигнализирует, что объект скоро будет удален (`PhantomReference<MyObject> phantomRef = new PhantomReference<>(new MyObject(), referenceQueue)`)

#### 7. Какой класс называют Immutable?
  Иммутабельный класс - класс, экземпляры которого не могут быть изменены после создания. Принципы создания:
  - Поля private `final`  
  - Никаких setter-ов
  - Сам класс делаем `final` 
  - Все поля устанавливаются через конструктор

#### 8. Расскажите про иерархию исключений
![alt text](image/Exception.png)

  **Interface Throwable** - общий предок для всех исключений

#### 9. Что такое Error и Exception?
  **Error** - Связаны с проблемами уровня JVM

  **Exception** - Являются результатом проблем в программе

#### 10. Расскажите про обрабатываемые и необрабатываемые исключения
  **Checked** - Exception. Должны обрабатываться блоком catch, или описываться в сигнатуре метода (IOException)

  **Unchecked** - Ошибки Error, а так же исключения времени выполнения (RuntimeException) и его наследниками. Могут не обрабатываться блоком catch и не быть описаны в сигнатуре метода


## КОЛЛЕКЦИИ

#### 1. Расскажите как выглядит иерархия коллекций
![alt text](image/Collections.png)

**Collection** и **Map** - два интерфейса, которые находятся на вершине иерархии JCF. Интерфейс Collection расширяют интерфейсы:
- List
- Queue
- Set

#### 2. Что такое ArrayList?
  Это список, реализованный на основе динамически расширяемого массива. То есть под капотом буквально создается массив

#### 3. Какая размерность массива(который под капотом) если создавать через конструктор без параметров?
Capacity = 10

#### 4. Можно ли задать начальную емкость списка?
Да, через конструктор (`List<String> list = new ArrayList<String>(15)`)

#### 5. Расскажите, что происходит под капотом при добавлении элемента в конец списка
Проверяется достаточно ли места для добавления нового элемента. Если достаточно, то он просто добавляется в конец. Иначе:
  1. Создается новый массив, в 1.5 + 1 раза превышающий предыдущий
  2. Копируются все элементы со старого массива + добавляется новый
  3. Удаляется старый массив

#### 6. Расскажите, что происходит под капотом при добавлении элемента в середину списка
Проверяется, достаточно ли места при добавлении нового элемента. Если достаточно - все элементы сдвигаются на один вправо. Если места недостаточно - происходит:
  1. Создается новый массив, в 1.5 + 1 раза превышающий предыдущий
  2. Копируются все элементы со старого массива + добавляется новый
  3. Удаляется старый массив

#### 7. Какая скорость добавления элемента в начало списка?
 Начало списка: **О(n)**

#### 8. Какая скорость добавления элемента в середину списка?
 Середину списка: **О(n)**

#### 9. Какая скорость добавления элемента в конец списка?
  Конец списка: **О(1)**

#### 10. Какая скорость доступа по индексу?
  **О(1)**

#### 11. Какая скорость удаления элемента в начале списка?
  Начало списка: **О(n)**

#### 12. Какая скорость удаления элемента в середине списка?
  Середина списка: **О(n)**

#### 13. Какая скорость удаления элемента с конца списка?
  Конец списка: **О(1)**

#### 14. Какая скорость доступа к элементам по значению?
  **О(n)** (т.к нужно итерироваться по всему списку пока не найдем нужное значение)

#### 15. Что такое LinkedList?
Классический двусвязный список, основанный на объектах с ссылками между ними. Реализует интерфейсы List и Deque. Данные хранятся в объектах типа Nod-ах

#### 16. Расскажите как работает добавление под капотом?
При создании LinkedList-а, у нас создается псевдо элемент - `Header` в котором хранятся next и prev, которые пока указывают сами на себя. После добавления элемента, ссылки next и prev у каждого объекта будут указывать на предыдущий и следующий.

#### 17. Сколько занимает добавление в начало списка?
  Начало списка: **О(1)**

#### 18. Сколько занимает добавление в середину списка?
  Середину списка: **О(n)**

#### 19. Сколько занимает добавление в конец списка?
  Конец списка: **О(1)**

#### 20. Сколько занимает удаление с начала списка?
  Начала списка: **О(1)**

#### 21. Сколько занимает удаление в середине списка?
  Середину списка: **О(n)**

#### 22. Сколько занимает удаление с конца списка?
  Конец списка: **О(1)**

#### 23. Сколько занимает чтение со списка по индексу?
  С начала и конца: **О(1)** (т.к есть доступ к первому и последнему элементу)

  С середины: **О(n)**

#### 24. Что такое TreeMap?
Класс в Java, который реализует интерфейс `NavigableMap`, который в свою очередь наследуется от `SortedMap`. Представляет собой ассоциативный массив, где ключи отсортированы в их естественным порядком
Единственная коллекция, которая **не использует** `equeals()` и `hashCode()` 
Основана на красно-черных деревьях

#### 25. Какая скорость операций у TreeMap?
**О(log n)** (т.к каждый раз отметается половина)

#### 26. Устройство TreeMap
Древовидная структура: под капотом TreeMap использует структуру данных, которая называется **красно-чёрное дерево**.

#### 27. Что такое HashMap?
Ассоциативный массив, хранит пары "ключ-значение". Ключ-уникальный, значение-может повторяться. Каждая ячейка массива - бакет(корзина), хранящий в себе односвязный список узлов. Если у односвязного списка node больше 8 элементов (коллизии), он превращается в красно-чёрное дерево, обратно - если количество элементов в бакете уменьшилось до 6. Может содержать один ключ null и любое количество значений null. Не отсортирован и не упорядочен

#### 28. Почему строка является популярным ключом в HashMap?
1. Иммутабельность (неизменяемость)
2. Хорошая реализация методов `hashCode()` и `equals()`
  

#### 29. Сколько изначально бакетов создается?
  По умолчанию - **16**

#### 30. В каком случае количество бакетов увеличивается?
Если массив бакетов заполнен на 75 процентов - создается х2 от начального размера

#### 31. Какая скорость операций?
  **О(1)**. Благодаря хеш-коду

#### 32. Опишите, как проходит процесс добавления объекта?
1. Вычисляется хеш-код ключ, на основании которого вычисляется бакет, в который будет добавлен новый элемент
2. Если бакет пустой - просто добавляем элемент
3. Если нет - идем по списку и сравниваем ключ добавляемого элемента и ключ элемента в списке по хеш-кодам
4. Если хеш-коды не равны - идем к следующему элементу
5. Если равны - сравниваем по `equals()`
6. Если ключи равны по `equals()` - перезаписываем value по этому ключу
7. Если ключи не равны по `equals()` - переходим к следующему элементу
8. Если мы не нашли ключ в списке, то добавляем этот элемент в конец списка
9. Так до тех пор, пока новое значение не перезапишет некоторое старое, или не достигнет конца односвязного списка и сохранится там последним элементом

#### 33. Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?
Да, будет, но в этом случае HashMap вырождается в связный список и теряет своим преимущества

#### 34. Почему предпочтительно использовать в качестве ключа immutable объект?
Потому что, если изменить объект на котором основан ключ, то у него поменяется хеш-код ⇒ найти элемент в HashMap-е не получится. Именно поэтому предпочтительно использовать immutable объекты (например String)

#### 35. Что такое HashSet?
HashSet — коллекция, не содержащая в себе дубликатов

#### 36. Как HashSet связан с HashMap?
HashSet использует HashMap для хранения элементов

#### 37. Сколько изначально бакетов создается в HashSet?
  По умолчанию - **16**

#### 38. В каком случае количество бакетов в HashSet увеличивается?
Если массив бакетов заполнен на 75 процентов - создается х2 от начального размера

#### 39. Какая скорость операций?
  **О(1)**. Благодаря хеш-коду

#### 40. Как проходит процесс добавления элемента в HashSet?
1. Получаем hashCode объекта, который мы помещаем в hashSet
2. Определяем в какой бакет класть объект (остаток от деления хеш-кода на кол-во бакетов)
3. Проверяется, существует ли уже элемент в бакете
4. Если нет - то элемент добавляется в бакет. Если есть - добавление игнорируется, т.к HashSet не допускает дубликатов

>P.S. Перед добавлением элемента - проверка. Если кол-во элементов == кол-ву бакетов - количество бакетов увеличивается на х2

#### 41. Будет ли работать HashSet, если все добавляемые элементы будут иметь одинаковый hashCode()?
Да, будет, но его производительность ухудшится. Если все элементы имеют одинаковый хеш-код, они все будут размещены в одном бакете, что приведет к увеличению времени поиска

#### 42. Что такое Queue?
Queue - это интерфейс в Java, который представляет собой коллекцию элементов, работающую по принципу "первый вошел — первый вышел" (**FIFO** — First In, First Out). 

#### 43. Какая скорость операций?
  **О(1)**

#### 44. Назовите главные реализации Queue?
1. LinkedList
2. ArrayDeque

#### 45. Что такое Deque?
Deque (Double-Ended Queue) — это интерфейс в Java, который представляет собой очередь с двумя концами. Это означает, что элементы могут быть добавлены или удалены как с начала, так и с конца очереди. Таким образом, Deque может работать как очередь (**FIFO**) и как стек (**LIFO**).

#### 46. Назовите главные реализации Deque?
1. LinkedList
2. ArrayDeque (Double ended queue)

#### 47. Какая скорость операций Deque?
  **О(1)**

#### 48. Какая коллекция реализует дисциплину обслуживания LIFO?
- Deque

